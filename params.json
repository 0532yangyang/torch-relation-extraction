{
  "name": "Torch-relation-extraction",
  "tagline": "Universal Schema based relation extraction implemented in Torch.",
  "body": "# Universal Schema based relation extraction implemented in Torch.\r\n\r\nPaper\r\n------------\r\nThis code was used for the paper [Multilingual Relation Extraction using Compositional Universal Schema](http://arxiv.org/abs/1511.06396) by Patrick Verga, David Belanger, Emma Strubell, Benjamin Roth, Andrew McCallum.\r\n\r\nIf you use this code, please cite us.\r\n\r\n\r\nDependencies\r\n-----------\r\n- [torch](https://github.com/torch/torch7)\r\n- [nn](https://github.com/torch/nn)\r\n- [rnn](https://github.com/Element-Research/rnn)\r\n- [optim](https://github.com/torch/optim)\r\n- [autograd](https://github.com/twitter/torch-autograd)\r\n- set this environment variable : TH_RELEX_ROOT=/path/to/this/proj\r\n\r\n\r\nOverview\r\n-------------\r\nUniversal Schema embeds text and knowledge base relations together to perform relation extraction and automatic knowledge base population. The typical universal schema model performs matrix factorization where rows are entity pairs and columns are relations.\r\n\r\nThis code allows you to perform matrix factorization where the column and row embeddings are parameterized by an arbitrary encoder. In the simplest case, a 'standard' matrix factorization would have each encoder as a lookup-table. More complex models could use combinations of LSTMs, CNNs, etc. To do this is as simple as setting the rowEncoder and colEnoder parameters\r\n\r\n`th src/UniversalSchema.lua -rowEncoder lookup-table -colEncoder lstm`\r\n\r\n\r\nData Processing\r\n--------------\r\nYour entity-relation data should be 4 col tsv.\r\n\r\nentity1 \\t entity2 \\t relation \\t 1\r\n\r\n`./bin/process/process-data.sh -i your-data -o your-data.torch -v vocab-file`\r\n\r\nThere are other flags in you can look at by doing `./bin/process/process-data.sh --help`\r\n\r\nYou can also process arbitrary data in 3 column format with the -b flag\r\n\r\nrow_value \\t col_value \\t 1\r\n\r\nIf you want your rows and columns to share the same vocabulary, use the -g flag   \r\n`./bin/process/process-data.sh -i your-3column-data -o your-data.torch -v vocab-file -b -g`\r\n\r\n\r\nTraining Models\r\n------------\r\nYou can run various Universal Schema models located in [src](https://github.com/patverga/torch-relation-extraction/blob/master/src/). Check out the various options in [CmdArgs.lua](https://github.com/patverga/torch-relation-extraction/blob/master/src/CmdArgs.lua)\r\n\r\nYou can train models using this [train script](https://github.com/patverga/torch-relation-extraction/blob/master/bin/train/train-model.sh). The script takes two parameters, a gpuid (-1 for cpu) and a [config file](https://github.com/patverga/torch-relation-extraction/tree/master/bin/train/configs). You can run an example base Universal Schema model and evaluate MAP with the following command. \r\n\r\n`./bin/train/train-model.sh 0 bin/train/configs/examples/uschema-example`\r\n\r\nEvaluation\r\n---------\r\n\r\n#### MAP\r\nMAP will be calculated every kth iteration based on the -evaluateFrequency cmd arg. AP is calculated on a per-column basis and then averaged to get MAP. To calculate MAP for your model, you need to generate one file per test column in the same format as your test data. Unlike the training data, in the test data you need to explicitly give negative examples. Negative samples should just have a 0 in the last column of the file while positive examples have a 1.\r\n\r\nPlace all of these files in a directory, test-data-dir for example, and then run the following command:   \r\n`./bin/process/process-test-data-dir.sh test-data-dir test-data-dir.torch vocab-file`   \r\nHere vocab-file should be the same vocab file that you generated your training data with.\r\n\r\n####  [TAC slot filling task](http://www.nist.gov/tac/2013/KBP/)\r\n- This requires setting up [Relation Factory](https://github.com/beroth/relationfactory) and setting $TAC_ROOT=/path/to/relation-factory. Just follow the setup instructions on the relation factory github or run `$TH_RELEX_ROOT/setup-relationfactory.sh`.\r\n\r\nFirst run :`./setup-tac-eval.sh` \r\n\r\nWe include candidate files for years 2012, 2013, and 2014 as well as [config files](https://github.com/patverga/torch-relation-extraction/tree/master/bin/tac-evaluation/configs/2013) to evaluate each year. \r\n\r\nYou can tune thresholds on year 2012 and evaluate on year 2013 with this command :\r\n\r\n`./bin/tac-evaluation/tune-and-score.sh 2012 2013 trained-model vocab-file.txt gpu-id max-length-seq-to-consider output-dir`\r\n\r\nYou can also download some [pretrained models](https://goo.gl/GeWyDk) from our paper [Multilingual Relation Extraction using Compositional Universal Schema](http://arxiv.org/abs/1511.06396). The download includes a script that will evaluate the models.\r\n\r\nRelation Extraction\r\n----------\r\nYou can also use this code to score relations. Here we'll walk through the steps to train a universal schema model. \r\n\r\n| e1         | e2            | relation  | 1 | \r\n| ------------- |:-------------:| -----| --- | \r\n| /m/02k__v | /m/01y5zy | $ARG1 lives in the city of $ARG2 | 1 | \r\n| /m/09cg6 | /m/0r297 | $ARG2 is a type of $ARG1 | 1 | \r\n| /m/02mwx2g | /m/02lmm0_ | /biology/gene_group_membership/gene | 1 | \r\n| /m/0hqv6zr | /m/0hqx04q | /medicine/drug_formulation/formulation_of | 1 | \r\n| /m/011zd3 | /m/02jknp | /people/person/profession | 1 | \r\n1. First create a training set that combines KB triples that you care about as well as text relations you care about. For example generate a file like the one above called train.tsv.\r\n2. Next, process that file : `./bin/process/process-data.sh -i train.tsv -o data/train.torch -v vocab-file`\r\n3. Now we want to train a model. Edit the [example lstm config](bin/train/configs/examples/lstm-example) to say `export TRAIN_FILE=train-mtx.torch` and start the model training :  `./bin/train/train-model.sh 0 bin/train/configs/lstm-example`. This will save a model to models/lstm-example/*-model every 3 epochs.\r\n4. Now we can use this model to perform relation extraction. Generate a candidate file called candidates.tsv. The file should be tab serparated with the following form :   \r\nentity_1 &nbsp;&nbsp;&nbsp;&nbsp; kb_relation&nbsp;&nbsp;&nbsp;&nbsp;entity_2 &nbsp;&nbsp;&nbsp;&nbsp; doc_info &nbsp;&nbsp;&nbsp;&nbsp; arg1_start_token_idx\t&nbsp;&nbsp;&nbsp;&nbsp; arg1_send_token_idx &nbsp;&nbsp;&nbsp;&nbsp;\targ2_start_token_idx &nbsp;&nbsp;&nbsp;&nbsp;\targ2_end_token_idx &nbsp;&nbsp;&nbsp;&nbsp; sentence.   \r\nA concrete example is :   \r\nBarack Obama &nbsp;&nbsp;&nbsp;&nbsp;\tper:spouse &nbsp;&nbsp;&nbsp;&nbsp;\tMichelle Obama &nbsp;&nbsp;&nbsp;&nbsp;\tdoc_info &nbsp;&nbsp;&nbsp;&nbsp;\t0\t&nbsp;&nbsp;&nbsp;&nbsp; 2 &nbsp;&nbsp;&nbsp;&nbsp;\t8\t &nbsp;&nbsp;&nbsp;&nbsp; 10  &nbsp;&nbsp;&nbsp;&nbsp; Barack Obama was seen yesterday with his wife Michelle Obama .   \r\n5. Finally, we can score each relation with the following command `th src/eval/ScoreCandidateFile.lua -candidates candidates.tsv -outFile scored-candidates.tsv -vocabFile vocab-file-tokens.txt -model models/lstm-example/5-model -gpuid 0`\r\n\r\nThis will generate a scored candidate file with the same number of lines and the sentenece replaced by a score where higher is more probable.  \r\n\r\nBarack Obama &nbsp;&nbsp;&nbsp;&nbsp;\tper:spouse &nbsp;&nbsp;&nbsp;&nbsp;\tMichelle Obama &nbsp;&nbsp;&nbsp;&nbsp;\tdoc_info &nbsp;&nbsp;&nbsp;&nbsp;\t0\t&nbsp;&nbsp;&nbsp;&nbsp; 2 &nbsp;&nbsp;&nbsp;&nbsp;\t8\t &nbsp;&nbsp;&nbsp;&nbsp; 10  &nbsp;&nbsp;&nbsp;&nbsp; 0.94 .\r\n\r\n\r\nContact\r\n----------\r\nFeel free to contact me with questions : patverga123@gmail.com\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}